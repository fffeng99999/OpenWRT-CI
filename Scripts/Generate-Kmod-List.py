#!/usr/bin/env python3
"""
该脚本会自动执行以下任务：
1. 【最终优化版】智能排序，准确查找 ImmortalWrt 官方源上 ipq807x 平台最新的 kmods 目录。
2. 通过解析 index.json 文件，高效获取所有可用的 kmod 软件包名。
3. 读取项目内 Config/GENERAL.txt 中已配置的 kmod 状态。
4. 生成一个只包含“未被内置(=y)”的 kmod 的新配置文件 (kmods-extra.txt)。
"""

import os
import re
import requests
from urllib.parse import urljoin

# 尝试导入 packaging 库，如果失败则提供安装提示
try:
    from packaging import version
except ImportError:
    print("ERROR: 'packaging' library not found. Please install it by running: pip3 install packaging")
    exit(1)


def find_latest_kmods_url():
    """通过版本排序，准确查找并返回最新的 kmods 目录 URL"""
    try:
        base_url = "https://downloads.immortalwrt.org/snapshots/targets/qualcommax/ipq807x/"
        kmods_index_url = urljoin(base_url, "kmods/")

        print(f"INFO: Fetching kmods index from: {kmods_index_url}")
        response = requests.get(kmods_index_url, timeout=30)
        response.raise_for_status()

        # 使用正则表达式查找所有看起来像内核版本的目录链接
        # 例如: 6.12.49-1-a4d57025ab62a3ef047692918fd4b58b/
        kernel_version_pattern = re.compile(r'href="(\d+\.\d+\.\d+-[^/]+/)"')
        found_versions = kernel_version_pattern.findall(response.text)

        if not found_versions:
            print("ERROR: No kernel version directories found.")
            return None

        # 解析并排序版本号
        # '6.12.49-1-...' -> version('6.12.49')
        parsed_versions = []
        for v_str in found_versions:
            try:
                # 提取版本号部分用于排序
                ver = version.parse(v_str.split('-')[0])
                parsed_versions.append((ver, v_str))
            except version.InvalidVersion:
                continue

        if not parsed_versions:
            print("ERROR: Could not parse any valid version numbers from directories.")
            return None

        # 按版本号降序排序
        parsed_versions.sort(key=lambda x: x[0], reverse=True)

        # 获取最新的版本目录名
        latest_dir_name = parsed_versions[0][1]
        latest_kmods_url = urljoin(kmods_index_url, latest_dir_name)

        print(f"INFO: Found latest kmods URL: {latest_kmods_url}")
        return latest_kmods_url

    except requests.exceptions.RequestException as e:
        print(f"ERROR: Cannot fetch kmods index: {e}")
    return None


def scrape_kmods_from_json(base_kmods_url):
    """从 index.json 文件中直接获取所有 kmod 包名"""
    scraped_kmods = set()
    json_url = urljoin(base_kmods_url, "index.json")
    try:
        print(f"INFO: Fetching kmod list from {json_url}...")
        response = requests.get(json_url, timeout=60)
        response.raise_for_status()
        data = response.json()

        packages = data.get("packages", {})
        for pkg_name in packages.keys():
            if pkg_name.startswith('kmod-'):
                scraped_kmods.add(pkg_name)

    except requests.exceptions.RequestException as e:
        print(f"ERROR: Cannot fetch or parse index.json: {e}")
    except ValueError:
        print(f"ERROR: Failed to decode JSON from {json_url}")
    return scraped_kmods


def get_explicitly_enabled_kmods(general_file_path):
    """
    【核心优化】从 GENERAL.txt 中只读取被明确设置为 '=y' 的 kmod。
    被设置为 '=n' 或未提及的包将不包含在此集合中。
    """
    enabled_kmods = set()
    try:
        with open(general_file_path, 'r', encoding='utf-8') as f:
            for line in f:
                # 只匹配严格以 "=y" 结尾的行
                match = re.match(r'^CONFIG_PACKAGE_(kmod-[^=]+)=y', line.strip())
                if match:
                    enabled_kmods.add(match.group(1))
    except FileNotFoundError:
        print(f"WARNING: {general_file_path} not found. Assuming no kmods are pre-included.")
    return enabled_kmods


def main():
    general_file = 'Config/GENERAL.txt'
    output_file = 'kmods-extra.txt'

    latest_url = find_latest_kmods_url()
    if not latest_url:
        print("ERROR: Failed to find latest kmods URL. Exiting.")
        open(output_file, 'w').close()
        return

    scraped_set = scrape_kmods_from_json(latest_url)
    if not scraped_set:
        print("ERROR: Failed to scrape any kmods. Exiting.")
        open(output_file, 'w').close()
        return

    print(f"INFO: Found {len(scraped_set)} unique kmods on the official server.")

    # 调用优化后的函数
    enabled_set = get_explicitly_enabled_kmods(general_file)
    print(f"INFO: Found {len(enabled_set)} kmods explicitly enabled ('=y') in {general_file}.")

    # 计算差集：官方有，但未在 GENERAL.txt 中被明确设置为 '=y' 的
    kmods_to_add = scraped_set - enabled_set
    print(f"INFO: Found {len(kmods_to_add)} extra kmods to compile (not set to '=y' in GENERAL.txt).")

    with open(output_file, 'w', encoding='utf-8') as f:
        f.write("# This file is auto-generated by Generate-Kmod-List.py. Do not edit.\n")
        f.write(
            "# It contains kmods that are available on the official server but not explicitly enabled in GENERAL.txt\n\n")
        for kmod in sorted(list(kmods_to_add)):
            f.write(f"CONFIG_PACKAGE_{kmod}=y\n")

    print(f"SUCCESS: Generated {output_file} with {len(kmods_to_add)} entries.")


if __name__ == "__main__":
    main()